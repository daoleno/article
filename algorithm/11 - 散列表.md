# 散列表

将键转化为数组的索引来访问数组中的键值对。

使用散列的查找算法分为两部。

1. 用散列函数将被查找的键转化为数组的一个索引

2. 处理碰撞冲突

![img](https://algs4.cs.princeton.edu/34hash/images/hashing-crux.png)

## 散列函数

对于每种类型的键，我们都需要一个与之一一对应的散列函数

### 正整数

散列正整数的常用方法是`除留余数法`

我们选择大小为素数 M 的数组，对于任意正整数 k，计算 K%M

![img](https://algs4.cs.princeton.edu/34hash/images/hashing-crux.png)

### 浮点数

将键表示为二进制数然后再使用除留余数法

### 字符串

除留余数法

散列字符串键

如果 R 比任何字符的值都大，这种计算相当于将字符串当作一个 N 位的 R 进制值，将它除以 M 并取余。
```java
int hash = 0;
for (int i = 0; i < s.length(); i++) {
    hash = (R * hash + s[i]) % M;
  }
```

### 组合键

如果键的类型含有多个变量，我们可以和 string 类型一样将他们混合起来。

DATE

```cpp
int hash = (((day * R + month) % M) * R + year  ) % M; 
```

### 将 hash() 的返回值转化为一个数组索引

```cpp
int hash(std::string key) {
  std::hash<std::string> hash_fn;
  return (hash_fn(key) & 0x7fffffff) % M;
}
```

### 软缓存

如果散列值的计算很耗时，我们可以将每个键的散列值缓存起来

总的来说，要为一个数据类型实现一个优秀的散列方法需要满足三个条件

* 一致性 --- 等价的键必然产生相等的散列值
* 高效性 --- 计算简便
* 均匀性 --- 均匀的散列所有的键

> 散列均匀假设：我们使用的散列的函数能够均匀并独立地将所有的键散布于 0 到 M-1 之间。

## 基于拉链法的散列表

拉链法：将大小为 M 的数组中的每个元素指向一条链表。链表中的每个结点都存储了散列值为该元素的索引的键值对。

标准索引用例使用基于拉链法的散列表

![img](https://algs4.cs.princeton.edu/34hash/images/separate-chaining.png)

## 基于线性探测法的散列表

开放地址散列表：用大小为 M 的数组保存 N 个键值对，其中 M > N。依靠数组中的空位解决碰撞冲突。

线性探测法：当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），我们直接检查散列表中的下一个位置（将索引值加一）。

这样的线性探测法可能会产生三种结果：

* 命中，该位置的键和被查找的键相同
* 为命中，键为空（该位置没有键）
* 继续查找，该位置的键和被查找的键不同

标准索引用例使用的基于线性探测的符号表的轨迹

![img](https://algs4.cs.princeton.edu/34hash/images/linear-probing.png)